<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>2026 World Cup Draw Simulator</title>
    <link rel="stylesheet" href="styles.css">
</head>
<div class="container">
    <h1>2026 World Cup Draw Simulator</h1>
    <div class="subtitle">
      Click ‚ÄúSimulate Draw‚Äù to watch the draw unfold.
    </div>

    <div class="controls">
      <button id="simulate-btn">Simulate Draw</button>
      <button id="skip-btn">Skip Animation</button>
    </div>

    <div class="status" id="status-text">
      Click "Simulate Draw" to start.
    </div>

    <div class="layout">
      <div class="pots" id="pots-container"></div>
      <div class="groups" id="groups-container"></div>
    </div>
  </div>

  <script src="app.js">
    // ========== DATA ==========

    const GROUPS = Array.from({ length: 12 }, (_, i) =>
      String.fromCharCode("A".charCodeAt(0) + i)
    );

    const pots = {
      1: [
        { name: "USA", flag: "üá∫üá∏" },
        { name: "Mexico", flag: "üá≤üáΩ" },
        { name: "Canada", flag: "üá®üá¶" },
        { name: "Spain", flag: "üá™üá∏" },
        { name: "Argentina", flag: "üá¶üá∑" },
        { name: "France", flag: "üá´üá∑" },
        { name: "England", flag: "üè¥Û†ÅßÛ†Å¢Û†Å•Û†ÅÆÛ†ÅßÛ†Åø" },
        { name: "Portugal", flag: "üáµüáπ" },
        { name: "Brazil", flag: "üáßüá∑" },
        { name: "Netherlands", flag: "üá≥üá±" },
        { name: "Belgium", flag: "üáßüá™" },
        { name: "Germany", flag: "üá©üá™" }
      ],
      2: [
        { name: "Croatia", flag: "üá≠üá∑" },
        { name: "Morocco", flag: "üá≤üá¶" },
        { name: "Colombia", flag: "üá®üá¥" },
        { name: "Uruguay", flag: "üá∫üáæ" },
        { name: "Switzerland", flag: "üá®üá≠" },
        { name: "Senegal", flag: "üá∏üá≥" },
        { name: "Austria", flag: "üá¶üáπ" },
        { name: "Japan", flag: "üáØüáµ" },
        { name: "Iran", flag: "üáÆüá∑" },
        { name: "South Korea", flag: "üá∞üá∑" },
        { name: "Ecuador", flag: "üá™üá®" },
        { name: "Australia", flag: "üá¶üá∫" }
      ],
      3: [
        { name: "Scotland", flag: "üè¥Û†ÅßÛ†Å¢Û†Å≥Û†Å£Û†Å¥Û†Åø" },
        { name: "Panama", flag: "üáµüá¶" },
        { name: "Norway", flag: "üá≥üá¥" },
        { name: "Egypt", flag: "üá™üá¨" },
        { name: "Algeria", flag: "üá©üáø" },
        { name: "Paraguay", flag: "üáµüáæ" },
        { name: "Tunisia", flag: "üáπüá≥" },
        { name: "Ivory Coast", flag: "üá®üáÆ" },
        { name: "Saudi Arabia", flag: "üá∏üá¶" },
        { name: "Uzbekistan", flag: "üá∫üáø" },
        { name: "Qatar", flag: "üá∂üá¶" },
        { name: "South Africa", flag: "üáøüá¶" }
      ],
      4: [
        { name: "Curacao", flag: "üá®üáº" },
        { name: "Jordan", flag: "üáØüá¥" },
        { name: "Cape Verde", flag: "üá®üáª" },
        { name: "Haiti", flag: "üá≠üáπ" },
        { name: "Ghana", flag: "üá¨üá≠" },
        { name: "New Zealand", flag: "üá≥üáø" },
        { name: "Italy", flag: "üáÆüáπ" },
        { name: "Turkiye", flag: "üáπüá∑" },
        { name: "Ukraine", flag: "üá∫üá¶" },
        { name: "Denmark", flag: "üá©üá∞" },
        { name: "DR Congo", flag: "üá®üá©" },
        { name: "Bolivia", flag: "üáßüá¥" }
      ]
    };

    // Confederations
    const confedByTeam = {
      // UEFA
      "Spain": "UEFA", "France": "UEFA", "England": "UEFA", "Portugal": "UEFA",
      "Netherlands": "UEFA", "Belgium": "UEFA", "Germany": "UEFA",
      "Croatia": "UEFA", "Denmark": "UEFA", "Switzerland": "UEFA",
      "Norway": "UEFA", "Austria": "UEFA", "Turkiye": "UEFA",
      "Ukraine": "UEFA", "Wales": "UEFA", "Italy": "UEFA",

      // CONMEBOL
      "Argentina": "CONMEBOL", "Brazil": "CONMEBOL", "Colombia": "CONMEBOL",
      "Uruguay": "CONMEBOL", "Ecuador": "CONMEBOL", "Paraguay": "CONMEBOL",
      "Bolivia": "CONMEBOL",

      // CONCACAF
      "USA": "CONCACAF", "Mexico": "CONCACAF", "Canada": "CONCACAF",
      "Panama": "CONCACAF", "Costa Rica": "CONCACAF", "Jamaica": "CONCACAF",

      // CAF
      "Morocco": "CAF", "Senegal": "CAF", "Tunisia": "CAF", "Ivory Coast": "CAF",
      "Algeria": "CAF", "Egypt": "CAF", "Ghana": "CAF", "DR Congo": "CAF",
      "Cape Verde": "CAF", "South Africa": "CAF",

      // AFC
      "Japan": "AFC", "Iran": "AFC", "South Korea": "AFC", "Australia": "AFC",
      "Uzbekistan": "AFC", "Qatar": "AFC", "Saudi Arabia": "AFC", "Jordan": "AFC",

      // OFC
      "New Zealand": "OFC"
    };

    // Sanity check ‚Äì optional
    (function checkConfeds() {
      const allTeams = new Set(
        Object.values(pots).flat().map(t => t.name)
      );
      const missing = [...allTeams].filter(t => !confedByTeam[t]);
      if (missing.length) {
        console.error("Missing confed mapping for:", missing);
      }
    })();

    // ========== UTILITIES ==========

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function slugify(name) {
      return name.toLowerCase().replace(/\s+/g, "-");
    }

    function getTeamInfoByName(name) {
      for (const pot of Object.values(pots)) {
        for (const t of pot) {
          if (t.name === name) return t;
        }
      }
      return { name, flag: "" };
    }

    // ========== CONFED RULES ==========

    function allowedInGroup(groupTeams, teamName) {
      const teamConf = confedByTeam[teamName];
      if (teamConf === "UEFA") return true;
      // For non-UEFA: no repeat confed in same group
      return groupTeams.every(t => confedByTeam[t] !== teamConf);
    }

    function groupsStateOk(groups) {
        for (const g of GROUPS) {
            const teams = groups[g];
            // Still enforce max 4 teams per group
            if (teams.length > 4) return false;

            const confCounts = {};
            for (const t of teams) {
            const c = confedByTeam[t];
            confCounts[c] = (confCounts[c] || 0) + 1;

            // New rule: no more than 2 teams from the same confederation
            // (UEFA included ‚Äî it can have 2, but not 3 or 4)
            if (confCounts[c] > 2) {
                return false;
            }
            }
        }
        return true;
    }

    function candidateGroupsForTeam(groups, teamName) {
      const cands = [];
      for (const g of GROUPS) {
        if (groups[g].length < 4 && allowedInGroup(groups[g], teamName)) {
          cands.push(g);
        }
      }
      return cands;
    }

    function backtrackAssignPot(groups, teams, steps, potNumber) {
      if (teams.length === 0) return true;

      // MRV heuristic ‚Äì team with fewest valid groups
      const sorted = [...teams].sort((a, b) =>
        candidateGroupsForTeam(groups, a).length -
        candidateGroupsForTeam(groups, b).length
      );

      const team = sorted[0];
      const remaining = teams.filter(t => t !== team);
      let candidates = candidateGroupsForTeam(groups, team);
      shuffle(candidates);

      for (const g of candidates) {
        groups[g].push(team);
        steps.push({ team, group: g, pot: potNumber });

        if (groupsStateOk(groups) && backtrackAssignPot(groups, remaining, steps, potNumber)) {
          return true;
        }

        // backtrack
        steps.pop();
        groups[g].pop();
      }
      return false;
    }

    // ========== DRAW SIMULATION ==========

    function simulateDrawWithSteps() {
      const groups = {};
      GROUPS.forEach(g => groups[g] = []);
      const steps = [];

      // Hosts in specific groups
      const hostAssignments = [
        { team: "Mexico", group: "A" },
        { team: "Canada", group: "B" },
        { team: "USA", group: "D" }
      ];
      for (const h of hostAssignments) {
        groups[h.group].push(h.team);
        steps.push({ team: h.team, group: h.group, pot: 1 });
      }

      // Remaining Pot 1 teams ‚Äì just fill the empty groups with 1 team each
      const hostNames = hostAssignments.map(h => h.team);
      const remainingPot1 = pots[1]
        .map(t => t.name)
        .filter(n => !hostNames.includes(n));
      shuffle(remainingPot1);

      const emptyGroups = GROUPS.filter(g => groups[g].length === 0);
      let idx = 0;
      for (const g of emptyGroups) {
        const team = remainingPot1[idx++];
        groups[g].push(team);
        steps.push({ team, group: g, pot: 1 });
      }

      // Pots 2‚Äì4 with backtracking
      for (const potNumber of [2, 3, 4]) {
        const teams = pots[potNumber].map(t => t.name);
        shuffle(teams);
        const ok = backtrackAssignPot(groups, teams, steps, potNumber);
        if (!ok) {
          // Very unlikely; if it fails, we just try again recursively
          console.warn("Backtracking failed; retrying whole draw.");
          return simulateDrawWithSteps();
        }
      }

      return { groups, steps };
    }

    // ========== DOM RENDERING ==========

    const potsContainer = document.getElementById("pots-container");
    const groupsContainer = document.getElementById("groups-container");
    const statusText = document.getElementById("status-text");
    const simulateBtn = document.getElementById("simulate-btn");
    const skipBtn = document.getElementById("skip-btn");

    function renderPots() {
      potsContainer.innerHTML = "";
      for (const potNumber of [1, 2, 3, 4]) {
        const card = document.createElement("div");
        card.className = "pot-card";

        const title = document.createElement("div");
        title.className = "pot-title";
        title.textContent = `Pot ${potNumber}`;
        card.appendChild(title);

        const ul = document.createElement("ul");
        ul.className = "pot-list";

        for (const team of pots[potNumber]) {
          const li = document.createElement("li");
          li.className = "team";
          li.id = `team-${slugify(team.name)}`;
          li.dataset.teamName = team.name;

          const flagSpan = document.createElement("span");
          flagSpan.className = "flag";
          flagSpan.textContent = team.flag;

          const nameSpan = document.createElement("span");
          nameSpan.textContent = team.name;

          li.appendChild(flagSpan);
          li.appendChild(nameSpan);
          ul.appendChild(li);
        }

        card.appendChild(ul);
        potsContainer.appendChild(card);
      }
    }

    function renderGroups() {
      groupsContainer.innerHTML = "";
      for (const g of GROUPS) {
        const card = document.createElement("div");
        card.className = "group-card";
        card.id = `group-${g}`;

        const header = document.createElement("div");
        header.className = "group-header";

        const name = document.createElement("div");
        name.className = "group-name";
        name.textContent = `Group ${g}`;

        const potLabel = document.createElement("div");
        potLabel.className = "group-pot-label";
        potLabel.textContent = "Drawn teams:";

        header.appendChild(name);
        header.appendChild(potLabel);

        const ul = document.createElement("ul");
        ul.className = "group-team-list";
        ul.dataset.groupName = g;

        card.appendChild(header);
        card.appendChild(ul);
        groupsContainer.appendChild(card);
      }
    }

    function clearVisualization() {
      // Clear group team lists
      for (const g of GROUPS) {
        const ul = document.querySelector(`#group-${g} .group-team-list`);
        if (ul) ul.innerHTML = "";
      }
      // Reset pot team highlight
      document
        .querySelectorAll(".team.drawn")
        .forEach(el => el.classList.remove("drawn"));
    }

    function applyStep(step) {
      const { team, group } = step;
      const teamInfo = getTeamInfoByName(team);

      // Mark team as drawn in its pot
      const potEntry = document.getElementById(`team-${slugify(team)}`);
      if (potEntry) {
        potEntry.classList.add("drawn");
      }

      // Add to group list
      const ul = document.querySelector(`#group-${group} .group-team-list`);
      if (ul) {
        const li = document.createElement("li");
        li.textContent = `${teamInfo.flag} ${teamInfo.name}`;
        ul.appendChild(li);
      }
    }

    // ========== ANIMATION CONTROL ==========

    let currentSteps = [];
    let currentStepIndex = 0;
    let drawIntervalId = null;
    const STEP_DELAY_MS = 550;

    function stopAnimation() {
      if (drawIntervalId !== null) {
        clearInterval(drawIntervalId);
        drawIntervalId = null;
      }
    }

    function startAnimation(steps) {
      stopAnimation();
      currentSteps = steps;
      currentStepIndex = 0;

      if (!steps.length) return;

      statusText.textContent = "Drawing teams...";

      drawIntervalId = setInterval(() => {
        if (currentStepIndex >= currentSteps.length) {
          stopAnimation();
          statusText.textContent = "Draw completed. Click ‚ÄúSimulate Draw‚Äù to run again.";
          return;
        }
        const step = currentSteps[currentStepIndex++];
        applyStep(step);

        const potLabel = step.pot ? `Pot ${step.pot}` : "Pot ?";
        statusText.textContent =
          `Drawn ${step.team} into Group ${step.group} (${potLabel})`;
      }, STEP_DELAY_MS);
    }

    function runSimulation() {
      stopAnimation();
      clearVisualization();

      statusText.textContent = "Computing valid draw...";
      // Slight timeout so UI updates before heavy calc (not strictly necessary, but nice)
      setTimeout(() => {
        const { steps } = simulateDrawWithSteps();
        startAnimation(steps);
      }, 10);
    }

    function skipAnimationToEnd() {
      if (!currentSteps.length) return;
      stopAnimation();
      clearVisualization();
      // Apply all steps instantly
      for (const step of currentSteps) {
        applyStep(step);
      }
      statusText.textContent = "Draw completed (skipped animation).";
    }

    // ========== INIT ==========

    renderPots();
    renderGroups();

    simulateBtn.addEventListener("click", runSimulation);
    skipBtn.addEventListener("click", skipAnimationToEnd);
  </script>
</body>
</html>
</html>